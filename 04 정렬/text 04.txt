04 정렬
- 정렬: 데이터를 정해진 기준에 따라 배치해 의미있는 구조로 제설정 하는 것

- 정렬 알고리즘 종류
    - 버블: 데이터의 인접요소끼리 비교하고 swap 연산을 수행하며 정렬하는 방식
    - 선택: 대상에서 가장 크거나 작은 데이터를 찾아가 선택을 반복하면서 정렬하는 방식
    - 삽입: 대상을 선택해 정렬된 영역에서 선택 데이터의 적절한 위치를 찾아 삽입하면서 정렬하는 방식
    - 퀵: pivot 값을 선정해 해당 값을 기준으로 정렬하는 방식
    - 병합: 이미 정렬된 부분 집합들을 효율적으로 병합해 전체를 정렬하는 방식
    - 기수: 데이터의 자릿수를 바탕으로 비교해 데이터를 정렬하는 방식


04-1 버블 정렬
    - 인접한 데이터의 크기를 비교해 정렬
    - 간단하지만 속도가 느린 편
    - 루프를 돌면서 swap연산으로 정렬

    - 정렬 과정
        1. 루프 범위 설정
        2. 인접 데이터 비교
        3. swap 조건에 부합하면 swap 수행
        4. 루프 범위가 끝날 때까지 2~3 반복
        5. 정렬 영역 설정, 다음 루프에는 이 영역 제외
        6. 비교대상이 없을때까지 1~5 반복

04-2 선택 정렬
    - 대상 데이터에서 최대나 최소 데이터를 데이터가 나열된 순서대로 찾아가며 선택하는 방법
    - 구현도 복잡 효율도도 떨어지기 때문에 잘 사용하지 않음
    넘어가겠음...

04-3 삽입 정렬
    - 구현은 쉽지만 느리다
    넘어가겠음..


04-4 퀵 정렬
    - 기준값(pivot)을 선정해 해당 값보다 작은 데이터와 큰 데이터로 분류해 반복정렬
    - 기준값에 따라 시간복잡도에 영향을 끼침(하지만 비교적 준수한 편이라 코테에서도 활용가능)
    - 시간복잡도 O(nlogn) ~ O(n^2)

    - 퀵 정렬 과정
        1. pivot 설정
        2. pivot을 기준으로 아래의 과정을 거쳐 데이터를 2개의 집합으로 분리
            a. start가 가리키는 데이터가 pivot이 가리키는 데이터보다 작으면 start를 오른쪽으로 1칸 이동
            a. start가 가리키는 데이터가 pivot이 가리키는 데이터보다 작으면 start를 오른쪽으로 1칸 이동
            b. end가 가리키는 데이터가 pivot이 가리키는 데이터보다 크면 end를 왼쪽으로 1칸 이동
            c. start가 가리키는 데이터가 pivot이 가리키는 데이터보다 크고, end가 가리키는 데이터를 swap하고 start는 오른쪽,
                end는 왼쪽으로 1칸씩 이동한다.
            d. start롸 end가 만날때까지 a ~c 반복
            e. start와 end가 만나면 만난 지점에서 가리키는 데이터와 pivot이 가리키는 데이터를 비교하여 pivot이 가리키는 데이터가 크면
                만난 지점의 오른쪽에, 작으면 만난 지점의 왼쪽에 pivot이 가리키는 데이터를 삽입한다.

        3. 분리 집합에서 각각 다시 pivot을 선정한다.
        4. 분리 집합이 1개 이하가 될 때까지 과정 1~3을 반복한다.

    - pivot 정하기
        - pivot == k: k번째 수를 찾은 것이므로 알고리즘 종료
        - pivot > k: pivot의 왼쪽 부분에 k가 있으므로 왼쪽(start~pivot - 1만 정렬을 수행
        - pivot < k: pivot의 오른쪽 부분에 k가 있으므로 오른쪽(pivot + 1~end)만 정렬을 수행

04-5 병합 정렬
    - 분할 정복 방식을 사용해 데이터를 분할하고 분할한 집합을 정렬하며 합치는 알고리즘
    - 시간 복잡도는 O(nlogn)
    - 2개씩 그룹을 합치며 오름차순으로 정렬
    - 투 포인터 개념을 사용해 그룹을 두개로 나눈 후 1번 그룹과 2번 그룹을 비교해가며 배열에 추가

04-6 기수 정렬
    - 값을 비교하지 않는 정렬
    - 값을 놓고 비교할 자리수를 정한 다음 해당 자릿수만 비교.
    - 시간복잡도 O(kn) # k는 자릿수
    - 데이터 개수가 많을 때 기수정렬이 유리

    - 막상 책 문제는 계수정렬임...
