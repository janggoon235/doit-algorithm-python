03-1 배열과 리스트
    - 배열과 리스트는 기본 개념은 다르나 python에서는 구분하지 않는다.

    배열 특징:
        1. 인덱스를 사용하여 값에 바로 접근
        2. 요소 삽입, 삭제가 어렵다. 삽입, 삭제시 주변 요소의 값들을 이동시켜야 한다.
        3. 배열의 크기를 선언시 지정 가능, 선언된 배열의 크기는 변화시킬 수 없다.
        4. 구조가 간단하여 코테에서 많이 사용

    리스트 특징:
        - 노드를 포인터로 연결한 자료구조
        1. 인덱스가 없어 Head 포인터부터 순서대로 접근. 요소 접근 속도가 느리다.
        2. 포인터로 연결되어 삽입, 삭제 연산속도가 빠르다.
        3. 크기가 정해져있지 않다.
        4. 포인터를 저장할 공간이 필요하여 배열보다 구조가 복잡하다.

    - 의사코드(슈도코드, pseudocode)는 프로그램을 작성할 때 각 모듈이 작동하는 논리를 표현하기 위한 언어


03-2 구간 합
    - 시간 복잡도를 줄이기 위한 특수 목적의 알고리즘

    구간 합의 핵심 이론

    - 합 배열 정의
        S[i] = A[0] + A[2] + ... + A[i-1] + A[i]
        A[0]부터 A[i]까지의 합

    - 합 배열 S를 만드는 공식
        S[i] = S[i-1] + A[i]

    - 구간 합을 구하는 공식
        # i에서 j까지 구간 합
        S[j] - S[i-1]

    - 2차원 구간 합 배열 D[X][Y] 정의
        D[X][Y] = 원본 배열의 (0, 0) 부터 (X, Y)까지의 사각형 영역 안에 있는 수의 합

    - D[i][j] 의 값을 채우는 구간 합 공식
        D[i][j] = D[i][j-1] + D[i-1][j] - D[i-1][j-1] + A[i][j]

    - (X1, Y1) ~ (X2, Y2) 구간 합
        sum[(X1, Y1) ~ (X2, Y2)] = D[X2][Y2] - D[X1-1][Y2] - D[X2][Y1-1] + D[X1-1][Y1-1]


    - 나머지 합 문제 풀이의 핵심 아이디어
        (A + B) % C = ((A%C) + (B%C)) % C
        특정 구간 수들의 나머지 연산을 더해 나머지를 연산한 값과 이 구간 합의 나머지 연산을 한 값은 동일하다.

        구간 합 배열을 이용한 식 S[j] - S[i]는 원본 리스트의 i +1 부터 j까지의 구간 합이다.
        S[j]%M의 값과 S[i]%M의 값이 같다면 (S[j] - S[i]) % M은 0이다.
        즉, 구간 합 배열의 원소를 M으로 나눈 나머지로 업데이트하고 S[j]와 S[i]가 같은 (i, j)쌍을 찾으면 원본 리스트에서 i+1부터 /
        j까지의 구간 합이 M으로 나누어 떨어진다는 것을 알 수 있다.


03-3 투 포인터
    - 2개의 포인터로 알고리즘 시간 복잡도를 최적화

    - 투 포인터 이동 원칙(두 포인터간 합이 목표수와 같은 경우의 수를 구할 때)
        sum == N: end_index++; sum = sum + end_index; count++;
        sum > N: sum = sum - start_index; start_index++;
        sum < N: end_index++; sum =sum + end_index;

    - 투 포인터 이동 원칙2(두 포인터의 합이 목표 수와 같은 경우의 수를 구할 때)
        A[i]+A[j]>M: j--;
        A[i]+A[j]<M: i++;
        A[i]+A[j]==M: i++; j--; count++;

    - 투 포인터 이동 원칙 3(두 포인터의 합이 범위 요소와 같은 경우의 수를 구할 때)

        A[i] + A[j] > K: j--;
        A[i] + A[j] < K: i++;
        A[i] + A[j] == K: count++;

03-4 슬라이딩 윈도우
    - 2개의 포인터로 범위를 유지한 채로 이동하여 문제를 해결


03-5 스택과 큐
    - 스택:
        - 삽입, 삭제가 LIFO로 이루어지는 자료구조
        - 깊이 우선 탐색, 백트래킹 종류에 효과적

    - 파이썬의 스택:
        top: 삽입과 삭제가 일어나는 위치
        append(data): top 위치에 데이터 삽입
        pop(): top 위치의 데이터 삭제 및 확인
        스택[-1]: top 위치의 데이터 단순 확인

    - 큐:
        - 삽입, 삭제가 FIFO으로 이루어지는 자료구조
        - 우선 너비 탐색에서 자주 사용
        - 우선순위 큐는 별개이며, 06자에서 설명

    - 파이썬의 큐:
        rear: 큐의 가장 끝 데이터 영역(실은 데이터를 가리키는 포인터 영역..)
        front: 큐의 가장 앞 데이터 영역
        append(data): rear부분에 새로운 데이터를 삽입
        popleft(): front 부분에 있는 데이터 삭제 및 확인
        큐[0]: 큐 front 데이터 확인

    스택 연산 수행 방법
        1. 현재 수열 값 >= 자연수
            - 현재 수열 값이 자연수보다 크거나 같을 때까지 자연수를 1씩 증가시키며 자연수를 스택에 append 한다.
            - append가 끝나면 수열을 출력 하기 위해 마지막 1회만 pop 한다.

        2. 현재 수열 값 < 자연수
            - pop으로 스택에 있는 값을 꺼낸다.
            - 꺼낸 값이 현재 수열 값이 아니면  'No'
            - 현재 수열 값이라면 조건문을 빠져나온다
